//1.compie 버전 세팅
//2. 컨트렉트 단위로 작성 => class 단위로 작성
//솔리디티 관점에서 컨트렉트는 무수한 코드들, 데이터가 작성되거나 보관된 형태
//이더리움 블록체인상에 특정 주소(hash)로 존재하는 것 
//솔리디티: 스마트 컨트렉트를 개발하는 언어
//변수
//함수


//기본타입
//1. 복합 데이터 타입(complex type) : 문자열, 구조체, 배열 <- 여러개의 데이터를 가지고 있다
//2. 기본 타입(basic type) : bool, int, float,... <- 단일 데이터를 가지고 있다

//주의사항:타입만 볼거니까 함수 형태는 신경을 안쓴다

//수치형
//int -> 정수 타입, int8~ int256, int ==int256
//uint -> 부호없는 정수타입(양수)
//부동소수점 : 
//fixed / ufixed : 고정크기 소수점 , 부호없는 고정크기 소수점 타입
//fixedMxN 형식:fixed128x19 => 128:비트수, 19:소수점자리수
//N:0~80가능, M:8~256사이 단,8의 배수만 가능
//bool:truef/false
//단일형 types: int, uint,bool,bytes,fixed,ufixed
//복합형 types:string,address,enum,tuple,struct

//열거형: enum
//주소형: address
//20byte 크기의 자료형
//컨트렉트의 주소,계좌의 주소등을 담는 변수 타입
//this : 현재 컨트렉트, 
//임의의(더미) 계좌 생성

//튜플
/*
- tuple, 값을 묶는다
- 여러 데이터를 묶을 때 사용
- 자료형이 달라도 ok
- 여러 데이터를 한 덩어리로 처리할때 유용 -> return
- (값, 값)
*/

//변수의 저장위치
//1.storage(스토리지) : 상태변수(멤버변수), 함수내의 로컬변수
//2.memory(메모리)   : 함수의 매개변수, 함수의 리턴값 -> 대부분 명시적 표현
//상태변수(멤버변수) -> storage(스토리지)
//지역변수 : 함수 내부에 위치한 변수

//생성자
//생성자의 인자값이 존재할 경우, 배포시 입력한다(테스트관점)
//컨트렉의 이름을 사용하지 않고(구버전은 사용했음)
//constructor 키워드에 함수 형태로 구현한다

//함수
/* 
 - 구조
function 함수명 ( 타입 x1, 타입x2, ...) options returns( 타입 x1, 타입x2, ...)
{
  //statement;,,,
  return(...) //<-생략가능
}
- options
1)가시성     : (access modifier)  
  - external : 컨트렉트상 명시된 것만 외부에 공개
  - public : 모든 컨트렉트의 내부 외부에 공개
  - internal : 해당 컨트렉트와 상속 컨트렉트에만 공개
  - private :  오직, 해당 컨트렉트만 공개
2)비용측면 : 
  - constant(x) (더이상 사용되지 않는다 정의) -> 이렇게 정의된 함수는 gas를 소모하지 않는다
  - view : 다음 행위를 함수 내부에서 하지 않겠다 <- 아래코드를 해야하면 view 사용 불가
   1) 상태 변수 값 변경
   2) 이벤트 발생(이벤트 -> 컨트렉트 -> nodejs쪽으로 이벤트 전달)
   3) 다른 컨트렉트 생성
   4) 이더 전송(송금)
   5) view나 pure로 선언되지 않은 함수 호출
  - pure : 다음 행위를 함수 내부에서 하지 않겠다 <- 아래코드를 해야하면 pure 사용 불가
               1) 상태 변수를 읽는다
               2) xx.balance 잔액확인등 접근시도
               3) 컨트렉트의 사전에 이미 정의된 전역객체들 block, tx, msg등을 접근행위
               4) pure로 정의되어 있지 않는 함수를 호출
  - payable : 비용이 발생된다. 돈이 움직이다
   ex) 컨트렉트가 멤버함수를 통해서 다른 지갑(타인), 이더를 송금하거나 받는 등 
   -> 함수 자체가 지불가능한 형태가 되는 경우 사용
*/

gas가 발생되지 않는 상황에서 상태변수를 읽는다 => view ok
//상태 변수를 수정함으로 view사용 불가
//뭔가 많은 일을 했다..
//상태변수를 사용 안햇다. 지불 관련 내용 없다
//t4함수를 구현하는데 부호없는정수 2개를 입력받아서 더한값을 리턴하는 함수를 구현하시오

//리턴할 변수를 returns에서 미리 지정하면 변수 선언 및 return도 생략 가능
//pure 함수 내부에서는 pure함수만 호출할 수 있다
//t(), t2() <- error

// 리턴값이 없으면 returns 생략
// 외부에서만 사용 가능
// 구현절차
/*
  - 1. 기능을 우선 구현 ( ~public returns(생략가능))
  - 2. 함수의 비용적인 측면 고려하여, view, pure, payable 사용
  - 3. 가시성에 대한 검토 후 최적의 가시성 구성
*/

// 생성자
// 상태변수
// 생성자에서 상태변수를 초기화
// 컨트렉트 생성

// 조건문 반복문 제어문 등
// 기본 문법은 기존 언어(자바, 자바스크립트 등) 별반 다르지 않다.
// if, for , while, do-while, break, continue
// 삼항 연산자
// 입력값이 1500이상이면 1을 리턴
// 1500보다 작으면 -1 리턴
// 1500과 같으면 0리턴

// 삼항 연산자 => 상황이 2개, 값을 리턴 혹은 세팅 포인트
// 조건 ? 참일때 값: 거짓일때 값
// 1부터 해당(인자)값까지의 누적합(총합)
// value에 5을 넣으면, 1+2+3+4+5 => 15
// 이런 부분 구현하이소

//forCheck2를 구현, 누적합, 누적곱을 구해서 리턴
//value에 5를 넣으면, 1+2+3+4+5 = >15
//value에 5를 넣으면, 1*2*3*4*5 = >120

// 형변환
// 타입의 형변환
// 1. 암묵적 형변환 : 작은 타입 => 큰타입, uint8 -> uint256
// 2. 명시적 형변환 : 큰타입 => 작은 타입, uint 256 -> uint8(데이터를 자르고, 자료형을 고정)
// uint8:0~2의 8승 -1
// 암묵적 형변환
// 명시적 형변환
// 복합타입 : 배열, 구조체, 문자열, 이벤트, ...
// 배열 선언 및 초기화
// 배열 선언 및 초기화의 사이즈 생략

// 함수, memory 키워드 사용
// memory 변수는 명시적으로 memory 키워드를 사용해야 한다.
// 함수 호출시 내부에만 존재하는 임시 변수(오직 함수내부)
// storage 변수 대비 저렴하다(싸다, 비용이 들지 않는다)
// 상태변수를 지역변수에 대입하는 행위
// 상태변수를 memory변수에 넣고 지역변수를 수정하면, 상태변수에 영향을 미치지 않는다.
why? 상태변수값이  카피되기때문에 상태변수는 보전된다.
// 바이트 배열
// byte,bytes
// bytes : 정벅 바이트 계열, 선언시 고정 크기를 가진다.
// 사이즈 overfull -> error
// 바이트 배열을 동적으로 구성하여, 사이즈 넘었을때 사용하면
// 유동적으로 조절이 된다. -> gas 발생, 고정크기를 권장
// 동적생성된 변수는 리턴 불가
// 바이츠 -> 바이트 배열에 복사
// 메모리로 선언된 변수를 리턴,생성
// 가나다
// 문자열, 아직 컴파일러가 발전하는 단계이므로,
// 우리가 편히 사용했던 라이브러리가 많이 없다.
// 일일이 만들어 줘야 한다.
// 문자열 기초 라이브러리 만들기
// 입력한 byte 배열의 크기만큼 bytes의 크기를 잡아준다.
// 인덱스별로 카피
// 문자열 변환, 모든 데이터는 bytes에 담겼으므로, string 변환

// 문자열 더하기
// addString
// input : string, string
// output : string
// 입력된 문자열을 이어 붙여서 리턴하는 함수
// 문자열을 bytes 변환하여 2개 합한 크기로 버퍼를 만들어서 차례대로 복사후
// 문자열화 시키면 
// 1. 함수의 외형부터 완성
// 2개 합한 크기로 버퍼를 만들어 -> dynamic create

// 문자열 자르기
// subString()
// input : string, offset(시작위치), len(길이)
// output : string
// 에러가 발생함으로 그냥 원본값을 리턴
// 정상적으로 자를 수 있다.(단, 한글은 배제, 바이트수가 달라서 방식이 다름)
// 자른 문자열이 들어갈 버퍼 생성 
// 1바이트 문자들만 해당, 영문, 숫자, 특수문자

// 매핑 : 자바(Map), 파이썬(딕셔너리), JS(객체)
// 키 : 값
// 키 : 모든 자료형이 올 수 있다.
// public getter 함수를 자동으로 만들어준다.
// 이 컨트렉트를 구동한자에게 금액을 세팅
// getter 함수는 get변수명(키) 가 아니라, 변수명(키) 이런식으로 구성
// 매핑 관련 작업, transaction에 적용되므로, 채굴을 통해 트렌젝션 처리가 된다.
// 따라서, 값을 세팅해도, 처리 전이므로 리턴 값이 0이다

// 구조체
// - 사용자 정의 타입
// - 어떤 타입의 변수도 맴버로 담을 수 있다.
// - 매핑형태의 키로는 사용이 불가
// - 구조체는 스토리지에 저장된다 -> 상태변수로만 존재
// - 자기참조 => depth 제한
// - 구조체 배열은 3번, 매핑값으로 대체하는 방식은 2번까지만 허용

// 구조체
// - 사용자 정의 타입
// - 어떤 타입의 변수도 맴버로 담을 수 있다.
// - 매핑형태의 키로는 사용이 불가
// - 구조체는 스토리지에 저장된다 -> 상태변수로만 존재
// - 자기참조 => depth 제한
// - 구조체 배열은 3번, 매핑값으로 대체하는 방식은 2번까지만 허용

// 플레이어 획득
// 구조체를 리턴한다면 삽입
// 함수 : getPlaterMean()
// 본 컨트렉트를 구동한자의 점수 평균값을 리턴하시오
// 구조체의 맴버를 접근할때는 구조체.맴버
// 타입, 값의 변화 신경써서 관리

// 자기 참조(재귀적)depth 제한
// B tree : 자기 자신을 자식으로 3번까지 가능

// binary tree : 이진트리, 자기 자신을 2번까지 가능

// 상속
// - 컨트렉트 상속, 부모의 맴버들을 그대로 사용 가능
// - 자식은 재정의, 맴버 추가 가능
// - 인터페이스, 추상컨트렉트
// C의 함수들은 어떤것?
// C는 A를 상속받고 B를 상속 받았다.
// 상속받은 함수들이 동일하면, 나중에 상속받은 함수가 최종

// 재정의
// 추상 컨트렉트
// 함수가 선언만 되어 있다.
// 스스로 생성 불가, 상속받아서 구현하는 구조
// 틀형태로 제공
// 컴파일 단계에서는 오류가 없으나, 배포 단계에서 에러가 난다 (구현하지않으면)
// 인터페이스의 함수는 external, 인자값은 calldata 추가
// 인터페이스 구현시 앞에 클래스와 동일한 함수가 겹치면 오류 발생
// 이벤트
// 디앱에서(솔리디티로 만든) 이벤트가 발생하여, 혹은 특정상황을 외부로
// 전달시키고자 할때 사용하는 방식이 이벤트
// 이벤트를 발생시키면, js에서는 콜백함수를 받아서 처리하게 된다
// -> 비동기, 트렌젝션 작업은 즉각적이지 않으므로 이벤트를 통해 외부로 전달
// 상황 : 뭔가 일을 했고, 그 대가로 지불하거나 등등

//  storage, memory, stack
/*
 - storage : 컨트렉트의 상태를 정의, sendTransaction으로 통해 상태 변경가능
 - memory : 함수 호출시 내부에만 존재하는 임시변수, storage보다 저렴
                 컨트렉트 레벨에서 사용 불가
 - stack : 개수가 제한적인 비용이 거의 들지 않는 영역
--------------------------------------------------------------------------------------
 - storage : 구조체, 배열, 매핑 등 선언하고 좋다.(디펄트로 storage에 저장) 상태변수
 - memory : 함수 인자, 함수 리턴값
 - stack : 언급되지 않는 케이스는 스택에 저장
*/
// f2()의 인자는 memory 였다
// f2()를 호출할때, 상태변수를 넣으면, 주소값이 전달되는것이 아니라,
// 사본이 전달된다. 따라서 아무리 수정을 해도, 사본이 수정되는 것이므로,
// 원본(상태변수) 유지된다.

// fEx()의 인자는 storage이다. 따라서 상태변수를 인자로 넣으면
// 참조값이 전달(실체가 전달) 따라서 조작하면, 원본도 조작된다.

// 라이브러리
// 특정 기능을 가진 함수들을 라이브러리라는 형태로 구성하여
// 네트워크 상에 배포를 하면 여러개의 컨트렉트들이 해당 라이브러리를
// 가져다가 사용할 수 있다.